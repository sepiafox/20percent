Development Journal of "The Flash Project" 
Lily Brucker username "sepiafox"

Week of February 1 2015
This week I researched how I could make a flash game with programs accessible to me. I also began to write the code for the program after looking at several tutorials about flash and actionscript. I am currently using FlashDevelop IDE to write the code, and I downloaded Flixel, a lybrary of common mechanics used in flash games. As far as coding goes, I have most of the main classes set out. These classes are the preloader, the main game file, and a state. I also have some basic specifications inside the classes like size and base background color. As far as the style of the actual game is involved, I have planned what I'm going to aim for. It will be a five-level platformer, each level with a single opponent. Each opponent will have a unique "power" that the player will gain after defeating them. Powers I'm considering are speed boost, teleportation accross the screen, infinite jump, and phasing through solid barriers. Which ones I use will probably be determined by how easy they are to incorperate into the game. The fifth and final boss will probably have all of the powers like the player by the end of the game.

Week of February 8 2015
This week I continued researching on how to make the basic flash application I had made work. This simple flash application just shows a static screen of a single color and specified size. I was using it's compilation to find any basic, setup related problems with how I was compiling and running projects before I went on to more complex things. I downloaded and assigned the proper SDK to the FlashDevelop Project and associated Flash Player with opening .SWF files. I also configured the debugger compiler. Additionally, I assigned my PlayState.as file to be my Document Class, or "Main", which was essential for the program to run, but that I had forgotten earlier. The game still does not compile, but that is due to an internal syntax error now, not the way the FlashDevelop project is set up. As far as conceptual game design goes, I have expanded in that area as well. Each of the five levels and bosses will have it's own state file. I may have a Menu state, depending on how easy it is, but that is not neccisarily essential and will be done last if at all.

Week of February 15 2015
This week I worked to fix existing syntax errors in compilation. I also experimented with different ways to execute my SWF file once it was compilable. I am currently just sending the SWF file link to my browser to play using Flash's web player, but if that turns out to not work I may have to install an internal player. I also tried rearranging file configurations to fix my compiler's problem of not being able to see the SWF file. This may be related to the way the SWF is executed, since both problems involve configuring the SWF, but I doubt it, as the error message (which is displayed in FlashDevelop whether I use the stricter Debug mode of compilation or just the release mode) describes not being able to find the file at all, rather than not being able to execute it. As far as game design goes, I have delved a bit into the artistic side and have a pretty good idea, after sketching a bit, what my characters and rooms will look like. I have yet to make finalized spritesheets on the computer and plan interesting obstacles for the rooms though. Lastly, I have deleted some unneccisary code from Playstate.

Week of February 22 2015
This week I focused on integrating flixel into a project successfully and putting the final touches on making sure the technicalities of smooth compiling were in place. The latter I accomplished by making a test project and adjusting the dimensions and color of the SWF to make sure my internal flash player wasn't just giving me a blank white screen. I also noted that this perfectly functioning project would become uncompilable (giving the error of it not bieng able to find the SWF file) if I tried compiling it with flixel incorrectly integrated, even if I deleted all the flixel code and project associations and saved it again. This would affect all projects and was only remedied by xing everything out and restarting the computer. However, after starting clean a few times I got a "Hello World" tester project working. FlashDevelop integrated and recognized the Flixel game lybrary and Flash fully rendering the SWF. I have replaced the 20percentproject file with this working tester project, named 20PERCENT. This is a major step forward - I can focus more on the objects in the actual game now instead of worrying about compliling problems.

Week of March 1 2015 - Checkpoint 1
I have finished the most major aspects of the game mechanics, completing the objective of getting the core mechanics working. I have made a sprite with moveable controls, which I am working on creating jump mechanics for right now. I have gravity mechanics done and controllable with variables. I also have a tiled background based on a binary data array. The background has working edge and block collisions, and the images it displays were made by me in gimp. The sprite's current animation art is a stock hooded figure, but I have the art for my own sprite almost completed. I just have to line each frame up right in the spritesheet so my sprite isn't displaced or cut off. The compiler has functioned well the entire time this week and all errors have been syntax-based. I have seperated the player controls and tilemap controls into thier own seperate classes, as well as try out several different images for my tilemap (which is why my tilemap image is called tilemap14).

Week of March 8 2015
This week I focused on the player sprite. I have pretty much completed the animations for the sprite, as each frame looks good and integrates into the game. I also have also made major improvements on the movement mechanics. I have fixed the "sliding" problem. This was how my sprite wouldn't stop moving, in regards to the x direction, until it hit a barrier. I fixed this by correcting the max velocity and removing misplaced acceleration mechanics. I also got the basics of my jump mechanics to work. The are only two physics related problems left. One is the max jump time. You can basically fly the sprite around the game. The second is the lack of acceleration mechanics. After I get these working, I am going to focus on an enemy Sprite, a fighting mechanism (probably shooting. Might make the projectiles some kind of sprite in and of themselves), a Menu state, and a health/points system. The biggest challenge I see in my way is the enemy sprite AI, but I have found several articles on that which are useful.

Week of March 15 2015
This week I worked on different ways of implementing jump and the beginnings of an enemy sprite. For jump, I made a code that let the character jump based on whether their velocity was zero, not based on a timer. The timer code is still there, just commented out. Though this motion-sensing approach generally is much smoother than the timer, it will occasionally result in inconsistencies as velocity is zero not only when on the ground but when the character sprite hits the ceiling of the playstate frame. I added another file to be the enemy sprite. I designed a whole other set of animations for it, and also updated the colors of the background and the player sprite. The enemy sprite works with the same mechanics as the player sprite but instead of being activated by keyboard inputs it is activated by booleans that will be the primary variables in developing the tracking "AI". As tracking of the player is important for the AI, I need to research what to call to get the player sprite's x and y position. Considering the layout of the blocks, the AI getting stuck behind blocks won't be a problem, but jumping onto the different levels might.

Week of March 22 2015
This week I worked on getting position variables recognized, the bullet sprite, and the AI. In order to design the AI of the enemy sprite, I had to keep track of where the player sprite was, but inside of the enemy class. This was more difficult than simply setting the variables to public or declaring them in the playstate rather than in the sprites, but the solution is probably a simple keyword. I added the basics of the AI logic by writing if statements for the enemy to follow the player, with more complicated logic involving booleans and trial-and-error to solve the problem of jumping, leaping down, and shooting without the enemy sprite getting stuck. I also added a class for the bullet sprite, and added basic instructions for it. The actual sprite sheet of the bullet is transparent except for the animations when the bullet is moved, so it appears as if the bullet comes from the player sprite.

Week of March 29 2015
This week I worked on implementing temporary timers in the enemy AI and expanding the code of the bullet sprites. I created a second class for the bullet type, rather than an instance or override because the mechanics were so different. I already had a bullet class that taylored to the player, so I was making one that matched up to the enemy. I put a simple timer in to shoot at certain intervals for the enemy bullet (as well as changing the color of the visible sprite), and also put a simple timer for moving the enemy sprite around as well. This is so I can work on the actual AI and other aspects of the game while still having a working enemy, and also so I can know that the code inside the various movement an timing if-statements. I have the variables names for the facing direction and position of all of the moving flixel sprites pinned down, but I am still having problems calling them without errors in the code due to private and public limitations.

Week of April 5 2015
This week I worked on a menu state to implement over the Playstate levels, as well as the beginnings of other level states. It is a seperate state that is called when the game is paused. I made a text field as the title, and may make the other clickable areas of the menu state, such as level choosing and restart, text fields as well. This depends on if text fields have the required inner framework to be interactive, or are able to be programmed easily to be interactive. If not, the text fields will probably be normal sprites with text and transparency for their animations and look. The main part of directly programming the menu state is storing the immediate memory of how far into the levels the player has gone, and being able to restart completely. I also got Playstates for other levels initialized. The logic is the same in all levels, but certain abilities of the player and enemy are not, as well as the color sheme of the Sprites and backgrounds.

Week of April 12 2015
This week I worked on implementing different states into the game and creating stored information on how far into the game the player was. I made a set of variables for unlocking each playstate in succession to represent levels, and made the menu state workable and with a toggle. I also made a set of variables within each playstate that saved it locally just for that level. I replaced the flixel text in the menu with sprites, so they would be more interactable. I also pinpointed how to get a sprites position and store it in a flixel point. This was integrated into the tracking in both bullet sprite classes. I am planning to integrate it into the enemy AI as well. I managed to make the game compilable again, and the enemy sprite's movement AI seems to be working but flawed in logic, as the sprite doesn't change direction when moving.

Week of April 19 2015 (side note: this friday our router broke completely so i had no access to my laptop and the pc wouldn't load, clone, or recognize the flashdevelop project files. I worked with code in the readme file, since editing existing text files is the only thing i can do right now.)
This week I worked on writing the extra "powers" for sprites, based on what I knew I could already do with the code I know. Increased speed is an easy feat, as is teleportation. I know how to destroy objects, so for teleportation I just save the players stats in an outside variable, destroy the sprite, and make a new player sprite from the saved variables. As far as player stats go, I have written code for them to have a health stat and an attack stat. The attack stat may be able to change the color of the bullet sprite(to represent increasing power of the bullet), if the variable privacy and inheritance of the situation can be made convenient. The other two enemies, out of the total four for each level, will likely have selective wind and double jump as powers. Wind can be easily simulated by implementing gravity-like mechanics in the x-direction. For it to be selective I need to able to control the area the wind happens in, perhaps tracking the enemy of whichever sprite is implementing it, or dividing the map into a set amount of zones. Double jump will be perfectly possible, but tricky, to implement as I’ll have to find a more complex way to find completion of jump than velocity, and will have to use timers and collision instead.
